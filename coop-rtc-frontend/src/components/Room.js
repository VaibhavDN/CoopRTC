import React, { useRef, useEffect, useState } from "react";
import io from "socket.io-client";

const Room = (props) => {
  const peerRef = useRef();
  const socketRef = useRef();
  const otherUser = useRef();
  const sendChannel = useRef();
  const [connectionStatus, setConnectionStatus] = useState("Disconnected");

  // useEffect hook: Everytime the component is rendered this function is called (arg 1). Arg 2 is
  // dependency array i.e. function is called only when values inside array are changed instead of being called during each render.
  useEffect(() => {
    socketRef.current = io.connect("https://cooprtc.herokuapp.com/");

    let timeout = setTimeout(() => {
      socketRef.current.emit("join room", {
        roomID: props.match.params.roomID,
        socketId: socketRef.current.id,
      }); // Sent to the server (server.js) indicating that we are trying to join a room. roomID is extracted from the url (react-router-dom way).
    }, 5000);

    socketRef.current.on("room filled", (roomID) => {
      console.log("Room full please create a new room.");
      setConnectionStatus("Room full please create a new room.");
      socketRef.current.close();
    });

    socketRef.current.on("other user", (userID) => {
      // Server sends the other users userID if they are present in the same room
      callUser(userID);
      otherUser.current = userID;
    });

    socketRef.current.on("user joined", (userID) => {
      // User already in the room gets notified about the new user by the server and gets their userID
      otherUser.current = userID;
    });

    socketRef.current.on("offer", handleOffer);

    socketRef.current.on("answer", handleAnswer);

    socketRef.current.on("ice-candidate", handleNewICECandidateMsg);

    return () => {
      clearTimeout(timeout);
    };
  }, []);

  function callUser(userID) {
    peerRef.current = createPeer(userID);
    sendChannel.current = peerRef.current.createDataChannel("sendChannel");
    sendChannel.current.onmessage = handleReceiveMessage;
  }

  function createPeer(userID) {
    // userID of user we are trying to call
    const peer = new RTCPeerConnection({
      iceServers: [
        {
          urls: "stun:openrelay.metered.ca:80",
        },
        {
          urls: "turn:openrelay.metered.ca:80",
          username: "openrelayproject",
          credential: "openrelayproject",
        },
        {
          urls: "turn:openrelay.metered.ca:443",
          username: "openrelayproject",
          credential: "openrelayproject",
        },
        {
          urls: "turn:openrelay.metered.ca:443?transport=tcp",
          username: "openrelayproject",
          credential: "openrelayproject",
        },
      ],
    });

    peer.onicecandidate = handleICECandidateEvent;
    peer.onnegotiationneeded = () => {
      handleNegotiationNeededEvent(userID);
    };
    peer.onconnectionstatechange = () => {
      if (peer.iceConnectionState === "disconnected") {
        handleDisconnect(userID);
      }
    };

    setConnectionStatus("Peer created..");
    return peer;
  }

  // Offer received from other user is set as remote description
  // Offer generated by us is set as local description
  function handleNegotiationNeededEvent(userID) {
    peerRef.current
      .createOffer()
      .then((offer) => {
        return peerRef.current.setLocalDescription(offer);
      })
      .then(() => {
        // Target userID, our userID and sdp i.e. actual offer data
        const payload = {
          target: userID,
          caller: socketRef.current.id,
          sdp: peerRef.current.localDescription,
        };
        socketRef.current.emit("offer", payload);
        setConnectionStatus("Offer sent..");
      })
      .catch((error) => console.log(error));
  }

  // When we get an offer
  function handleOffer(incoming) {
    peerRef.current = createPeer(); // We are not making the call so no need to pass userID
    peerRef.current.ondatachannel = (event) => {
      console.log("data channel active..");
      sendChannel.current = event.channel;
      sendChannel.current.onmessage = handleReceiveMessage;
    };
    const desc = new RTCSessionDescription(incoming.sdp);
    peerRef.current
      .setRemoteDescription(desc)
      .then(() => {
        return peerRef.current.createAnswer();
      })
      .then((answer) => {
        // Answer is similar to offer, it is also sdp data
        return peerRef.current.setLocalDescription(answer);
      })
      .then(() => {
        const payload = {
          target: incoming.caller,
          caller: socketRef.current.id,
          sdp: peerRef.current.localDescription,
        };
        socketRef.current.emit("answer", payload);
        setConnectionStatus("Answer sent..");
      });
  }

  function handleAnswer(message) {
    const desc = new RTCSessionDescription(message.sdp);
    peerRef.current
      .setRemoteDescription(desc)
      .catch((error) => console.log(error));
    setConnectionStatus("Received answer..");
  }

  function handleICECandidateEvent(event) {
    if (event.candidate) {
      const payload = {
        target: otherUser.current,
        candidate: event.candidate,
      };
      socketRef.current.emit("ice-candidate", payload);
      setConnectionStatus("ICEC sent..");
    }
  }

  function handleNewICECandidateMsg(incoming) {
    const candidate = new RTCIceCandidate(incoming);

    peerRef.current
      .addIceCandidate(candidate)
      .catch((error) => console.log(error));
    setConnectionStatus("ICEC received..");
  }

  function handleReceiveMessage(event) {
    console.log(event.data);
    if (socketRef.current.connected) {
      socketRef.current.close();
      setConnectionStatus(
        "Peers connected. Connection with server closed. Do not close this page. Enjoy!"
      );
    }
  }

  function handleDisconnect(userID) {
    setConnectionStatus("Peer connection lost");
  }

  return (
    <div>
      <div style={{ alignContent: "center" }}>CoopRTC</div>
      <div>
        <input
          type="text"
          onChange={(event) => {
            sendChannel.current.send(event.target.value);
            if (socketRef.current.connected) {
              socketRef.current.close();
              setConnectionStatus(
                "Peers connected. Connection with server closed. Do not close this page. Enjoy!"
              );
            }
          }}
        />
      </div>
      <div>Id: {socketRef?.current?.id || "Unallocated"}</div>
      <div>Status: {connectionStatus}</div>
    </div>
  );
};

export default Room;
